const id = "simple-go-vs-goroutines.mdx";
						const collection = "blog";
						const slug = "simple-go-vs-goroutines";
						const body = "\n## Goroutine vs Simple function\n\nThis is a simple example of why goroutines might be **overkill** for some tasks and less efficient than a simple function.\n\n<br />\n\n## Structures\n\nWe got a simple structure that contains sensitive information that we don't want to be exposed to the outside world.\nTherefore, we created a second structure that hides the sensitive information and only exposes the information we want to be public.\n\n```go\n// Pineapple is a struct that represents a database object with sensitive data that should be hidden\ntype Pineapple struct {\n\tParo       string `faker:\"name\"`\n\tTurkey     string `faker:\"name\"`\n\tBanana     string `faker:\"name\"`\n\tAge        int    `faker:\"number\"`\n\tSize       int    `faker:\"number\"`\n\tIsAlive    bool\n\tID         uint\n\tSecretCode []byte\n\tCreated    time.Time\n\tUpdated    time.Time\n}\n\n// SafePineApple is a struct that represents a Pineapple object without sensitive data\ntype SafePineApple struct {\n    Paro    string\n    Turkey  string\n    Banana  string\n    IsAlive bool\n    Age     int\n    ID      uint\n}\n```\n\n<br />\n\n## Conversion\n\nWe need to convert our Pineapple object to a SafePineApple object.\nWe can do this by creating a method on the Pineapple struct that returns a SafePineApple object.\n\n```go\n// ToSafePineApple converts a Pineapple object to a SafePineApple object\nfunc (p *Pineapple) ToSafePineApple() SafePineApple {\n\treturn SafePineApple{\n\t\tParo:    p.Paro,\n\t\tTurkey:  p.Turkey,\n\t\tBanana:  p.Banana,\n\t\tIsAlive: p.IsAlive,\n\t\tAge:     p.Age,\n\t\tID:      p.ID,\n\t}\n}\n```\n\n<br />\n\n## Use case\n\nIn our use case we have an **array of Pineapple objects** coming from our database that we want to convert to **SafePineApple objects** and store them in a **new array**.\nThe **order of the objects** in the array should be the same as the original array as it has already been sorted by a sql query.\n\n<br />\n\n## Simple function\n\nWe can do this by creating a simple function that takes an array of Pineapple objects and returns an array of SafePineApple objects.\n\n```go\n// SimpleConvertPineApplesToSafety converts an array of Pineapple objects to an array of SafePineApple objects\nfunc SimpleConvertPineApplesToSafety(pineapples []Pineapple) []SafePineApple {\n\tsafePineApples := make([]SafePineApple, len(pineapples))\n\n\tfor idx, pineapple := range pineapples {\n\t\tsafePineApples[idx] = pineapple.ToSafePineApple()\n\t}\n\n\treturn safePineApples\n}\n```\n\n<br />\n\nThis function is very **simple** and **easy to understand**. We loop through the array of Pineapple objects and convert them to SafePineApple objects.\n\n<br />\n\n## Goroutine without mutex\n\nWe can do this by using **goroutines** to work on the array concurrently and store the results in a new array.\n\n```go\nfunc GoroutinesNoMutexConvertPineApplesToSafety(pineapples []Pineapple) []SafePineApple {\n\t// Create a slice to store the SafePineApples\n\tsafePineApples := make([]SafePineApple, len(pineapples)/2, len(pineapples))\n\tsafePineApples2 := make([]SafePineApple, len(pineapples)/2)\n\n\tvar wg sync.WaitGroup // Create a WaitGroup to wait for all goroutines to finish\n\twg.Add(1)            // Add 1 to the WaitGroup\n\n\t// Create a goroutine to convert the first half of the Pineapple objects\n\tgo func(chunk []Pineapple) {\n\t\tdefer wg.Done() // Decrement the WaitGroup when the goroutine is done\n\t\tfor idx, pineapple := range chunk { // Loop through the chunk of Pineapple objects\n\t\t\tsafePineApples[idx] = pineapple.ToSafePineApple() // Convert the Pineapple object to a SafePineApple object\n\t\t}\n\t}(pineapples[:len(pineapples)/2]) // Pass the first half of the Pineapple objects to the goroutine\n\n\t// Convert the second half of the Pineapple objects in the main thread\n\tfor idx, pineapple := range pineapples[len(pineapples)/2:] {\n\t\tsafePineApples2[idx] = pineapple.ToSafePineApple()\n\t}\n\n\t// Wait for all goroutines to finish\n\twg.Wait()\n\n\t// Group both pineapples\n\tsafePineApples = append(safePineApples, safePineApples2...)\n\n\t// Return the SafePineApples\n\treturn safePineApples\n}\n```\n\n<br />\n\nThis function is a bit more **complex** than the simple function. We use a goroutine to convert the first half while the other half is handled by the main thread.\nWe use a **WaitGroup** to wait for the goroutine to finish before returning the results.\n\n<br />\n\n## Goroutine with mutex\n\nWe can also add **mutexes** to the goroutine to make it **thread safe**.\n\n```go\nfunc GoroutinesConvertPineApplesToSafety(pineapples []Pineapple) []SafePineApple {\n\t// Create a slice to store the SafePineApples\n\tsafePineApples := make([]SafePineApple, len(pineapples))\n\n\t// Split the offers into chunks\n\tchunks := [][]Pineapple{pineapples[:len(pineapples)/2], pineapples[len(pineapples)/2:]}\n\n\tmutex := sync.Mutex{} // Create a mutex to lock the slice when writing to it\n\n\tvar wg sync.WaitGroup // Create a WaitGroup to wait for all goroutines to finish\n\twg.Add(1)           // Add 1 to the WaitGroup\n\n\t// Create a goroutine to convert the first half of the Pineapple objects\n\tgo func(chunk []Pineapple) {\n\t\tdefer wg.Done() // Decrement the WaitGroup when the goroutine is done\n\t\tfor idx, pineapple := range chunk { // Loop through the chunk of Pineapple objects\n\t\t\tmutex.Lock() // Lock the mutex\n\t\t\tsafePineApples[idx] = pineapple.ToSafePineApple() // Convert the Pineapple object to a SafePineApple object\n\t\t\tmutex.Unlock()  // Unlock the mutex\n\t\t}\n\t}(chunks[0]) // Pass the first half of the Pineapple objects to the goroutine\n\n\t// Convert the second half of the Pineapple objects in the main thread\n\tfor idx, pineapple := range chunks[1] {\n\t\tmutex.Lock() // Lock the mutex\n\t\tsafePineApples[idx+len(chunks[0])] = pineapple.ToSafePineApple() // Convert the Pineapple object to a SafePineApple object\n\t\tmutex.Unlock() // Unlock the mutex\n\t}\n\n\t// Wait for all goroutines to finish\n\twg.Wait()\n\n\treturn safePineApples\n}\n```\n\n<br />\n\nThis function make use of the mutex to lock the slice when writing to it.\nThis makes sure that the goroutine and the main thread don't write to the same index at the same time but instead wait for the other to finish.\n\n<br />\n\n## Benchmark\n\nNow that we have our functions we can benchmark them to see which one is the **fastest.**\nTo benchmark our functions we run them with arrays of different sizes.\n\nOur benchmark function looks like this:\n\n```go\nfunc Benchmark_SimpleConvertPineApplesToSafety(b *testing.B) {\n\tfor _, n := range []int{500, 1000, 2000, 5000, 10000} {\n\t\tb.Run(fmt.Sprintf(\"Benchmark_SimpleConvertPineApplesToSafety-%d\", n), func(b *testing.B) {\n\t\t\tpineApples := make([]Pineapple, n)\n\t\t\tvar pine Pineapple\n\t\t\tfor i := 0; i < n; i++ {\n\t\t\t\t_ = faker.FakeData(&pine)\n\t\t\t\tpine.Created = time.Now().AddDate(0, 0, -i)\n\t\t\t\tpine.ID = uint(i)\n\t\t\t\tpine.IsAlive = true\n\t\t\t\tpineApples[i] = pine\n\t\t\t}\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\tSimpleConvertPineApplesToSafety(pineApples)\n\t\t\t}\n\t\t})\n\t}\n}\n```\n\n<br />\n\nTo run the benchmark we use the following command:\n\n```bash\ngo test -bench=. -benchtime 5s > benchmark.txt && benchstat benchmark.txt\n```\n\n<br />\n\nBenchstat is a tool that can be used to compare the results of benchmarks.\n\nThe results of the benchmark are as follows:\n\n```bash\nname                                                                        time/op\nBenchmark_SimpleConvertPineApplesToSafety-500-32                          15.8µs ± 0%\nBenchmark_SimpleConvertPineApplesToSafety-1000-32                         32.0µs ± 0%\nBenchmark_SimpleConvertPineApplesToSafety-2000-32                         66.5µs ± 0%\nBenchmark_SimpleConvertPineApplesToSafety-5000-32                          193µs ± 0%\nBenchmark_SimpleConvertPineApplesToSafety-10000-32                         465µs ± 0%\nBenchmark_GoroutinesConvertPineApplesToSafety-500-32                      23.5µs ± 0%\nBenchmark_GoroutinesConvertPineApplesToSafety-1000-32                     46.2µs ± 0%\nBenchmark_GoroutinesConvertPineApplesToSafety-2000-32                     87.7µs ± 0%\nBenchmark_GoroutinesConvertPineApplesToSafety-5000-32                      242µs ± 0%\nBenchmark_GoroutinesConvertPineApplesToSafety-10000-32                     507µs ± 0%\nBenchmark_NoMutexGoroutinesConvertPineApplesToSafety-500-32               28.3µs ± 0%\nBenchmark_NoMutexGoroutinesConvertPineApplesToSafety-1000-32              48.7µs ± 0%\nBenchmark_NoMutexGoroutinesConvertPineApplesToSafety-2000-32               105µs ± 0%\nBenchmark_NoMutexGoroutinesConvertPineApplesToSafety-5000-32               257µs ± 0%\nBenchmark_NoMutexGoroutinesConvertPineApplesToSafety-10000-32              533µs ± 0%\n```\n\n<br />\n\nAs you can see the **simple function is the fastest**.\n\n## Why ?\n\nThe reason why the simple function is the fastest is that the process of converting the Pineapple objects to SafePineApple objects is very fast.\nThe time it takes to create the goroutines and wait for them to finish is longer than the time it takes to convert the Pineapple objects to SafePineApple objects.\n\n<br />\n\nFurthermore, in our goroutines implementation we have to convert the Pineapple objects then lock the mutex, write to the slice and unlock the mutex.\nThis is a lot of **overhead for a very simple task**.\n\n<br />\n\n## Conclusion\n\n*Don't use goroutines when you don't need them.* That may seem obvious, but it's easy to forget when you're trying to optimize your code.\nIn this example the overhead of creating the goroutines and waiting for them to finish is **longer** than the time it takes to convert the Pineapple objects to SafePineApple objects.\n\nGoroutines are great for tasks that take a **long time to complete** and can be done in parallel.\nI would suggest to write the **simplest code possible** and then benchmark it to see if you can improve it using goroutines instead.\n\nMoreover, simple code is **easier to read and maintain** than complex code, that's why writing complex code might not be necessary if performance is not an issue.\n**I'd prefer to have a simple function that takes a few milliseconds longer to complete than a complex function.**\n\n<br />\n\n## Code\n\nThe code for this article can be found on <a href=\"https://github.com/CorentinGS/go-teaching/tree/main/goroutines_simple_vs_complex\" class=\"font-bold underline text-accent\"> GitHub </a>\n";
						const data = {title:"Goroutine vs Simple function",description:"Goroutine vs Simple function",pubDate:new Date(1673478000000),heroImage:
						new Proxy({"src":"/_astro/simple-go-vs-goroutines.BQLadO_l.webp","width":1632,"height":918,"format":"webp","fsPath":"/workspaces/corentings.github.io/src/assets/blog/simple-go-vs-goroutines.webp"}, {
						get(target, name, receiver) {
							if (name === 'clone') {
								return structuredClone(target);
							}
							if (name === 'fsPath') {
								return "/workspaces/corentings.github.io/src/assets/blog/simple-go-vs-goroutines.webp";
							}
							
							return target[name];
						}
					})
					,category:"Programming",tags:["Optimization","Benchmark","Golang"],draft:false};
						const _internal = {
							type: 'content',
							filePath: "/workspaces/corentings.github.io/src/content/blog/simple-go-vs-goroutines.mdx",
							rawData: undefined,
						};

export { _internal, body, collection, data, id, slug };
