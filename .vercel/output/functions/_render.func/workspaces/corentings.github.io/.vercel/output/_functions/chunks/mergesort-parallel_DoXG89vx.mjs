const id = "mergesort-parallel.mdx";
						const collection = "blog";
						const slug = "mergesort-parallel";
						const body = "\n## Parallel Merge Sort vs Simple Merge Sort\n\nThis is a simple example of how to use goroutines to **parallelize** a merge sort algorithm.\nWe compare the performance of a simple merge sort algorithm with a parallel merge sort algorithm that uses goroutines.\n\n<br />\n\n## The Merge Sort Algorithm\n\nThe merge sort algorithm is a divide and conquer algorithm that recursively splits the input array into two halves,\nsorts each half, and then merges the two sorted halves into a single sorted array.\n\n<br />\n\nTo speed up the merge sort algorithm, we use insertion sort for small subarrays (less than 12 elements).\n\n<br />\n\nThe implementation of the algorithm uses generics to allow sorting of any type of numbers.\n\n```go\nfunc MergeSort[T Number](items []T) []T {\n\tsize := len(items)\n\tif size < 2 {\n\t\treturn items\n\t}\n\n\tif size < K {\n\t\treturn Insertionsort(items)\n\t}\n\n\tmiddle := size / 2\n\tvar a = MergeSort(items[:middle])\n\tvar b = MergeSort(items[middle:])\n\n\treturn merge(a, b)\n}\n```\n\n<br />\n\n## The Merge Sort Algorithm with Goroutines\n\nThe parallel merge sort algorithm uses **goroutines** to sort the two halves of the input array in parallel.\n\nTo prevent the creation of too many goroutines, we use a **threshold** to determine when to use goroutines.\nIf the size of the input array is less than the threshold,\nwe use a simple merge sort algorithm instead of a parallel one.\n\n<br />\n\nHere we use a threshold of 512 elements. We can benchmark the performance of the algorithm with\ndifferent thresholds to find the optimal threshold, but we will not do that in this example.\n\n```go\n// ParallelMerge Perform merge sort on a slice using goroutines\nfunc ParallelMerge[T Number](items []T) []T {\n\tif len(items) < 2 {\n\t\treturn items\n\t}\n\n\t// Use a simple merge sort algorithm if the size of the input array is less than the threshold\n\tif len(items) < 512 {\n\t\treturn MergeSort(items)\n\t}\n\n\t// Create the wait group to wait for the goroutines to finish\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\n\tvar middle = len(items) / 2  // Find the middle index of the input array\n\tvar a []T                   // Create a slice to hold the first half of the input array\n\tgo func() {                // Create a goroutine to sort the first half of the input array\n\t\tdefer wg.Done()       // Decrement the wait group counter when the goroutine finishes\n\t\ta = ParallelMerge(items[:middle]) // Sort the first half of the input array\n\t}()\n\tvar b = ParallelMerge(items[middle:]) // Sort the second half of the input array\n\n\twg.Wait() // Wait for the goroutine to finish\n\treturn merge(a, b) // Merge the two sorted halves\n}\n```\n\n<br />\n\n## Benchmarking the Merge Sort Algorithms\n\nNow we can benchmark our merge sort algorithms to compare their **performance**.\n\nTo benchmark the algorithms, we use arrays of different sizes and **measure the time** it takes to sort the arrays.\n\n<br />\n\nTo run the benchmark we use the following command:\n\n```bash\ngo test -bench=. -benchtime 5s > benchmark.txt && benchstat benchmark.txt\n```\n\n<br />\n\nBenchstat is a tool that can be used to compare the results of benchmarks.\n\nThe results of the benchmark are as follows:\n\n```bash\nname                                   time/op\nMergesort/1000                     14.6µs ± 0%\nMergesort/10000                     473µs ± 0%\nMergesort/100000                   6.33ms ± 0%\nMergesort/1000000                  87.4ms ± 0%\n\nMergesortWithGoroutines/1000       18.7µs ± 0%\nMergesortWithGoroutines/10000       217µs ± 0%\nMergesortWithGoroutines/100000     2.71ms ± 0%\nMergesortWithGoroutines/1000000    29.0ms ± 0%\n```\n\n<br />\n\nAs we can see, the parallel merge sort algorithm is **much faster** than the simple merge sort algorithm for **large arrays**.\n\n<br />\n\n## Why is the Parallel Merge Sort Algorithm Faster?\n\nThe parallel merge sort algorithm is faster because it uses goroutines to sort the two halves of the input array in **parallel**.\nThe simple merge sort algorithm sorts the two halves of the input array **sequentially**.\n\n<br />\n\nAs discussed in the previous article, the cost of **creating a goroutine can be high**.\nSo we should use a parallel merge sort algorithm only when the size of the input array is **large enough to justify the cost** of creating goroutines.\n\n<br />\n\n## Conclusion\n\nIn this example, we have seen how to use **goroutines to parallelize** a merge sort algorithm. We have also benchmarked the performance of the merge sort algorithms to compare their performance.\nGoroutines are a **powerful tool** that should be used **only when the cost of creating goroutines is justified** by the performance improvement.\n\nIn this example, the code isn't more complex when using goroutines therefore it's worth using them.\n\n## Code\n\nThe code for this article can be found on <a href=\"https://github.com/CorentinGS/go-teaching/tree/main/goroutines_merge_sort\" class=\"font-bold underline text-accent\"> GitHub </a>\n";
						const data = {title:"Merge Sort using Goroutines",description:"This is a simple example of how to use goroutines to implement a merge sort algorithm.",pubDate:new Date(1673478000000),heroImage:
						new Proxy({"src":"/_astro/mergesort-parallel.Bc0vtqZo.webp","width":1491,"height":972,"format":"webp","fsPath":"/workspaces/corentings.github.io/src/assets/blog/mergesort-parallel.webp"}, {
						get(target, name, receiver) {
							if (name === 'clone') {
								return structuredClone(target);
							}
							if (name === 'fsPath') {
								return "/workspaces/corentings.github.io/src/assets/blog/mergesort-parallel.webp";
							}
							
							return target[name];
						}
					})
					,category:"Programming",tags:["Benchmark","Algorithm","Golang"],draft:false};
						const _internal = {
							type: 'content',
							filePath: "/workspaces/corentings.github.io/src/content/blog/mergesort-parallel.mdx",
							rawData: undefined,
						};

export { _internal, body, collection, data, id, slug };
